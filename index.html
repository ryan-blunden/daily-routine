<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Daily Setlist</title>
    <link rel="icon" href="data:," />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Manrope:wght@400;500;700&display=swap" rel="stylesheet" />
    <style>
      :root {
        --bg: #0b0f14;
        --panel: #101722;
        --ink: #eaf0fa;
        --muted: #8fa0b8;
        --line: #1d2938;
        --accent: #37d0ff;
        --accent-2: #4bffbe;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        background: var(--bg);
        font-family: "Manrope", sans-serif;
        color: var(--ink);
      }

      .stage {
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 24px;
      }

      .page {
        width: min(980px, 92vw);
        background: var(--panel);
        border: 1px solid #263547;
        box-shadow: 0 22px 70px rgba(0, 0, 0, 0.55);
        padding: 46px;
        display: grid;
        grid-template-rows: auto auto 1fr;
        gap: 30px;
        position: relative;
        overflow: hidden;
      }

      .page::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: linear-gradient(rgba(255, 255, 255, 0.004) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.004) 1px, transparent 1px);
        background-size: 18px 18px;
        pointer-events: none;
      }

      .header {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: start;
        gap: 4mm;
        border-bottom: 1px solid var(--line);
        padding-bottom: 4mm;
      }

      .header-meta {
        display: grid;
        justify-items: end;
        gap: 2mm;
        min-width: 58mm;
      }

      .title {
        font-family: "Bebas Neue", sans-serif;
        letter-spacing: 0.08em;
        font-size: 13mm;
        line-height: 0.9;
        margin: 0;
      }

      .title strong {
        color: var(--accent);
      }

      .today-date {
        margin: 0;
        text-align: right;
        font-size: 9pt;
        letter-spacing: 0.05em;
        color: var(--muted);
      }

      .header-progress {
        --progress: 0%;
        min-width: 34mm;
        border: 0.8px solid rgba(143, 160, 184, 0.28);
        border-radius: 2mm;
        padding: 1.6mm 2.2mm;
        position: relative;
        overflow: hidden;
      }

      .header-progress::before {
        content: "";
        position: absolute;
        inset: 0;
        width: var(--progress);
        background: linear-gradient(90deg, rgba(55, 208, 255, 0.28), rgba(75, 255, 190, 0.18));
        pointer-events: none;
        transition: width 220ms ease;
      }

      .header-progress > * {
        position: relative;
        z-index: 1;
      }

      .header-progress b {
        display: block;
        font-size: 7pt;
        letter-spacing: 0.07em;
        color: var(--muted);
        margin-bottom: 0.8mm;
        text-transform: uppercase;
      }

      .header-progress .metric {
        font-size: 10pt;
        font-weight: 700;
        color: var(--ink);
        letter-spacing: 0.02em;
      }

      .schedule {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        column-gap: 5.2mm;
        row-gap: 5.2mm;
        align-content: start;
      }

      .top-panels {
        display: grid;
        grid-template-columns: minmax(0, 1.55fr) minmax(0, 1fr);
        gap: 5.2mm;
        align-items: stretch;
      }

      .top-panels > * {
        min-width: 0;
      }

      .goals-box,
      .deliverables-box {
        border: 1px solid var(--line);
        border-radius: 2.5mm;
        padding: 3.4mm 3.6mm;
        background: rgba(255, 255, 255, 0.015);
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .goals-box h2,
      .deliverables-box h2 {
        margin: 0 0 1.8mm 0;
        font-size: 8pt;
        letter-spacing: 0.07em;
        text-transform: uppercase;
        color: var(--accent);
      }

      .goals-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 1.2mm 5mm;
      }

      .goals-list li {
        display: flex;
        align-items: center;
        gap: 1.2mm;
        font-size: 7.2pt;
        line-height: 1.35;
        padding: 0.4mm 0;
        cursor: default;
        flex: 0 1 auto;
        min-width: 0;
      }

      .goal-count-wrap {
        display: inline-flex;
        align-items: center;
        gap: 1.2mm;
      }

      .goal-count {
        width: 9mm;
        height: 4.8mm;
        border: 1px solid var(--line);
        border-radius: 1.1mm;
        background: rgba(255, 255, 255, 0.03);
        color: var(--ink);
        font: inherit;
        font-size: 7.1pt;
        text-align: center;
        padding: 0.2mm 0.6mm;
      }

      .goal-count:focus {
        outline: none;
        border-color: var(--accent);
      }

      .deliverables-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 1.2mm;
      }

      .deliverables-list li {
        display: grid;
        grid-template-columns: 3.5mm 1fr;
        gap: 2mm;
        align-items: start;
        font-size: 7pt;
        line-height: 1.35;
        padding: 0.4mm 0;
        cursor: pointer;
      }

      .deliverables-list .task-label {
        word-break: break-word;
      }

      .block {
        border: 1px solid var(--line);
        border-radius: 2.5mm;
        padding: 2.8mm 3mm;
        background: rgba(255, 255, 255, 0.015);
        margin: 0;
        height: 45mm;
        display: flex;
        flex-direction: column;
      }

      .block h2 {
        margin: 0 0 0.6mm 0;
        min-height: 4.8mm;
        font-size: 7.7pt;
        line-height: 1.2;
        letter-spacing: 0.07em;
        text-transform: uppercase;
        color: var(--accent);
      }

      .block .time {
        margin: 0 0 0.8mm 0;
        min-height: 3.1mm;
        font-size: 6.9pt;
        color: var(--muted);
        letter-spacing: 0.06em;
      }

      .block .desc {
        margin: 0 0 1.1mm 0;
        min-height: 3.2mm;
        font-size: 6.7pt;
        color: #ffffff;
        letter-spacing: 0.01em;
      }

      ul {
        list-style: none;
        margin: 2mm 0 0 0;
        padding: 0;
        display: grid;
        gap: 1.1mm;
      }

      .block li:nth-child(n + 5) {
        display: none;
      }

      li {
        display: grid;
        grid-template-columns: 3.5mm 1fr;
        gap: 2mm;
        align-items: start;
        font-size: 7pt;
        line-height: 1.35;
        padding: 0.4mm 0;
        cursor: pointer;
      }

      li input[type="checkbox"] {
        appearance: none;
        width: 3.2mm;
        height: 3.2mm;
        margin-top: 0.25mm;
        border: 1px solid var(--line);
        border-radius: 0.8mm;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
      }

      li input[type="checkbox"]:checked {
        border-color: var(--accent);
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        box-shadow: 0 0 0 1px rgba(11, 15, 20, 0.45) inset;
      }

      li .task-text.done {
        color: var(--muted);
        text-decoration: line-through;
      }

      li .task-label {
        cursor: pointer;
      }

      .goals-list .task-label {
        cursor: text;
      }

      @media (max-width: 980px) {
        .page {
          padding: 34px;
          gap: 24px;
        }

        .top-panels {
          grid-template-columns: 1fr;
        }

        .goals-list {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .header {
          grid-template-columns: 1fr;
          gap: 2.8mm;
        }

        .header-meta {
          justify-items: start;
        }

        .today-date {
          text-align: left;
        }

      }

      @media (max-width: 640px) {
        .goals-list {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="stage">
      <main class="page">
        <header class="header">
          <h1 class="title" id="planner-title">DAILY <strong>SETLIST</strong></h1>
          <div class="header-meta">
            <p class="today-date" id="today-date"></p>
            <article class="header-progress" aria-label="Daily status">
              <b>Progress</b>
              <span class="metric" id="tasks-percent">0%</span>
            </article>
          </div>
        </header>

        <section class="top-panels" aria-label="Goals and deliverables">
          <section class="goals-box" aria-label="Daily goals">
            <h2>Daily Goals</h2>
            <ul class="goals-list" id="daily-goals"></ul>
          </section>
          <section class="deliverables-box" aria-label="Top 3 deliverables">
            <h2>Top 3 Deliverables</h2>
            <ul class="deliverables-list" id="top-deliverables"></ul>
          </section>
        </section>

        <section class="schedule" aria-label="Routine schedule" id="schedule"></section>

      </main>
    </div>
  </body>
  <script>
    (async () => {
      const STORAGE_PREFIX = "daily-setlist-state-v1:";
      const titleEl = document.getElementById("planner-title");
      const todayDateEl = document.getElementById("today-date");
      const headerProgressEl = document.querySelector(".header-progress");
      const goalsEl = document.getElementById("daily-goals");
      const deliverablesEl = document.getElementById("top-deliverables");
      const scheduleEl = document.getElementById("schedule");
      const percentEl = document.getElementById("tasks-percent");

      const toLocalISODate = (d) => {
        const off = d.getTimezoneOffset();
        const local = new Date(d.getTime() - off * 60000);
        return local.toISOString().slice(0, 10);
      };

      const slug = (s) =>
        s
          .toString()
          .toLowerCase()
          .replace(/&/g, "and")
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-+|-+$/g, "");

      const unquote = (s) => {
        if (!s) return "";
        const q = s.trim();
        if (q.startsWith('"') && q.endsWith('"')) {
          return q
            .slice(1, -1)
            .replace(/\\"/g, '"')
            .replace(/\\\\/g, "\\");
        }
        return q;
      };

      const parseTomlValue = (raw) => {
        const value = raw.trim();
        if (value.startsWith("[") && value.endsWith("]")) {
          const inner = value.slice(1, -1).trim();
          if (!inner) return [];
          const matches = inner.match(/"((?:\\"|[^"])*)"/g) || [];
          return matches.map((m) => unquote(m));
        }
        if (value === "true") return true;
        if (value === "false") return false;
        if (/^-?\d+(\.\d+)?$/.test(value)) return Number(value);
        return unquote(value);
      };

      const parseTomlPlanner = (toml) => {
        const data = { blocks: [] };
        let currentBlock = null;
        const lines = toml.split(/\r?\n/);
        for (let i = 0; i < lines.length; i += 1) {
          const rawLine = lines[i];
          const line = rawLine.replace(/\s+#.*$/, "").trim();
          if (!line) continue;
          if (line === "[[blocks]]") {
            currentBlock = { title: "", time: "", items: [] };
            data.blocks.push(currentBlock);
            continue;
          }
          const match = line.match(/^([A-Za-z0-9_-]+)\s*=\s*(.+)$/);
          if (!match) continue;
          const [, key, initialRawValue] = match;
          let rawValue = initialRawValue;

          if (rawValue.trim().startsWith("[") && !rawValue.trim().endsWith("]")) {
            const parts = [rawValue];
            while (i + 1 < lines.length) {
              i += 1;
              const nextLine = lines[i].replace(/\s+#.*$/, "").trim();
              if (!nextLine) continue;
              parts.push(nextLine);
              if (nextLine.endsWith("]")) break;
            }
            rawValue = parts.join(" ");
          }

          const target = currentBlock || data;
          target[key] = parseTomlValue(rawValue);
        }
        return data;
      };

      const normalizePlannerData = (raw) => {
        const blocks = Array.isArray(raw?.blocks)
          ? raw.blocks.map((b) => ({
              title: String(b?.title || ""),
              time: String(b?.time || ""),
              description: String(b?.description || ""),
              items: Array.isArray(b?.items) ? b.items.map((i) => String(i)) : []
            }))
          : [];

        return {
          titlePrefix: String(raw?.title_prefix || "DAILY"),
          titleAccent: String(raw?.title_accent || "SETLIST"),
          goals: Array.isArray(raw?.goals) ? raw.goals.map((g) => String(g)) : [],
          topDeliverables: Array.isArray(raw?.top_deliverables) ? raw.top_deliverables.map((d) => String(d)) : [],
          blocks
        };
      };

      const fetchText = async (path) => {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) throw new Error(`Unable to load ${path}`);
        return res.text();
      };

      const loadPlannerData = async () => {
        try {
          const tomlText = await fetchText("planner-data.toml");
          return normalizePlannerData(parseTomlPlanner(tomlText));
        } catch (_) {
          const jsonText = await fetchText("planner-data.json");
          return normalizePlannerData(JSON.parse(jsonText));
        }
      };

      const setHeaderTitle = (titlePrefix, titleAccent) => {
        titleEl.textContent = "";
        titleEl.append(document.createTextNode(`${titlePrefix} `));
        const accent = document.createElement("strong");
        accent.textContent = titleAccent;
        titleEl.append(accent);
      };

      const renderDescriptionHtml = (el, html) => {
        const template = document.createElement("template");
        template.innerHTML = String(html || "");
        const allowedTags = new Set(["B", "STRONG", "I", "EM", "U", "SMALL", "CODE", "BR", "SPAN", "A"]);
        const walker = document.createTreeWalker(template.content, NodeFilter.SHOW_ELEMENT);
        const replaceWithText = [];

        while (walker.nextNode()) {
          const node = walker.currentNode;
          const tag = node.tagName;
          if (!allowedTags.has(tag)) {
            replaceWithText.push(node);
            continue;
          }

          [...node.attributes].forEach((attr) => {
            const name = attr.name.toLowerCase();
            const value = attr.value.trim();
            const isAnchorAttr = tag === "A" && (name === "href" || name === "target" || name === "rel");
            if (name.startsWith("on")) {
              node.removeAttribute(attr.name);
            } else if (tag === "A" && name === "href" && /^\s*javascript:/i.test(value)) {
              node.removeAttribute("href");
            } else if (!isAnchorAttr && name !== "class") {
              node.removeAttribute(attr.name);
            }
          });

          if (tag === "A") {
            if (!node.getAttribute("target")) node.setAttribute("target", "_blank");
            node.setAttribute("rel", "noopener noreferrer");
          }
        }

        replaceWithText.forEach((node) => {
          node.replaceWith(document.createTextNode(node.textContent || ""));
        });

        el.replaceChildren(template.content.cloneNode(true));
      };

      const renderBlocks = (blocks) => {
        scheduleEl.textContent = "";
        blocks.forEach((block, blockIndex) => {
          const article = document.createElement("article");
          article.className = "block";

          const heading = document.createElement("h2");
          heading.textContent = block.title;

          const time = document.createElement("p");
          time.className = "time";
          time.textContent = block.time;

          const desc = document.createElement("p");
          desc.className = "desc";
          renderDescriptionHtml(desc, block.description);

          const list = document.createElement("ul");
          const cappedItems = block.items.slice(0, 4);
          cappedItems.forEach((item, itemIndex) => {
            const li = document.createElement("li");
            li.setAttribute("role", "group");

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            const taskId = `${blockIndex}-${slug(block.title)}-${itemIndex}`;
            checkbox.dataset.taskId = taskId;
            checkbox.id = `task-${taskId}`;
            checkbox.name = `task-${taskId}`;
            checkbox.setAttribute("aria-label", item);

            const label = document.createElement("label");
            label.className = "task-text task-label";
            label.textContent = item;
            label.htmlFor = checkbox.id;

            li.append(checkbox, label);
            list.append(li);
          });

          article.append(heading, time, desc, list);
          scheduleEl.append(article);
        });
      };

      const renderGoals = (goals) => {
        goalsEl.textContent = "";
        goals.forEach((goal, goalIndex) => {
          const li = document.createElement("li");
          li.setAttribute("role", "group");

          const goalText = String(goal).trim();
          const goalMatch = goalText.match(/^(\d{1,3})\s+(.+)$/);
          const target = goalMatch ? Number(goalMatch[1]) : 0;

          const goalInput = document.createElement("input");
          goalInput.type = "text";
          goalInput.className = "goal-count";
          goalInput.inputMode = "numeric";
          goalInput.pattern = "[0-9]*";
          goalInput.autocomplete = "off";
          goalInput.placeholder = "00";
          const goalId = `goal-${goalIndex}-${slug(goal)}`;
          goalInput.dataset.taskId = goalId;
          goalInput.dataset.goalTarget = String(target);
          goalInput.id = `task-${goalId}`;
          goalInput.name = `task-${goalId}`;
          goalInput.setAttribute("aria-label", goal);

          const label = document.createElement("label");
          label.className = "task-text task-label";
          label.textContent = goalText;
          label.htmlFor = goalInput.id;

          const counterWrap = document.createElement("div");
          counterWrap.className = "goal-count-wrap";
          counterWrap.append(goalInput);

          li.append(counterWrap, label);
          goalsEl.append(li);
        });
      };

      const renderDeliverables = (deliverables) => {
        deliverablesEl.textContent = "";
        deliverables.slice(0, 3).forEach((item, itemIndex) => {
          const li = document.createElement("li");
          li.setAttribute("role", "group");

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          const taskId = `deliverable-${itemIndex}-${slug(item)}`;
          checkbox.dataset.taskId = taskId;
          checkbox.id = `task-${taskId}`;
          checkbox.name = `task-${taskId}`;
          checkbox.setAttribute("aria-label", item);

          const label = document.createElement("label");
          label.className = "task-text task-label";
          label.textContent = item;
          label.htmlFor = checkbox.id;

          li.append(checkbox, label);
          deliverablesEl.append(li);
        });
      };

      const today = toLocalISODate(new Date());
      const todayLabel = new Intl.DateTimeFormat("en-GB", {
        weekday: "long",
        day: "numeric",
        month: "long",
        year: "numeric"
      }).format(new Date());
      todayDateEl.textContent = todayLabel;

      const keyForDate = () => STORAGE_PREFIX + today;
      const getStateInputs = () => [...document.querySelectorAll('[data-task-id]')];
      const getTaskCheckboxes = () => [...document.querySelectorAll('.schedule li input[type="checkbox"]')];

      const readState = () => {
        const raw = localStorage.getItem(keyForDate());
        if (!raw) return {};
        try {
          return JSON.parse(raw);
        } catch (_) {
          return {};
        }
      };

      const writeState = () => {
        const payload = {};
        getStateInputs().forEach((el) => {
          if (el.type === "checkbox") {
            payload[el.dataset.taskId] = el.checked;
          } else {
            const digits = String(el.value || "").replace(/\D/g, "").slice(0, 2);
            payload[el.dataset.taskId] = digits ? Number(digits) : 0;
          }
        });
        localStorage.setItem(keyForDate(), JSON.stringify(payload));
      };

      const updateMetrics = () => {
        const checks = getTaskCheckboxes();
        const total = checks.length;
        const done = checks.filter((cb) => cb.checked).length;
        const percent = total ? Math.round((done / total) * 100) : 0;
        percentEl.textContent = `${percent}%`;
        if (headerProgressEl) {
          headerProgressEl.style.setProperty("--progress", `${percent}%`);
        }

        checks.forEach((cb) => {
          const text = cb.nextElementSibling;
          if (text) text.classList.toggle("done", cb.checked);
        });

        const deliverableChecks = [...document.querySelectorAll('.deliverables-list input[type="checkbox"]')];
        deliverableChecks.forEach((cb) => {
          const text = cb.nextElementSibling;
          if (text) text.classList.toggle("done", cb.checked);
        });

        const goalInputs = [...document.querySelectorAll(".goals-list .goal-count[data-task-id]")];
        goalInputs.forEach((input) => {
          const target = Number(input.dataset.goalTarget || "0");
          const value = Number(input.value || "0");
          const label = input.closest("li")?.querySelector(".task-label");
          if (label) label.classList.toggle("done", target > 0 && value >= target);
        });
      };

      const loadState = () => {
        const state = readState();
        getStateInputs().forEach((el) => {
          const saved = state[el.dataset.taskId];
          if (el.type === "checkbox") {
            el.checked = Boolean(saved);
          } else {
            const digits = String(saved ?? "").replace(/\D/g, "").slice(0, 2);
            el.value = digits;
          }
        });
        updateMetrics();
      };

      document.addEventListener("change", (e) => {
        if (e.target.matches('input[type="checkbox"], input.goal-count')) {
          writeState();
          updateMetrics();
        }
      });

      document.addEventListener("input", (e) => {
        if (!e.target.matches("input.goal-count")) return;
        const digits = e.target.value.replace(/\D/g, "").slice(0, 2);
        e.target.value = digits;
        writeState();
        updateMetrics();
      });

      const plannerData = await loadPlannerData();
      setHeaderTitle(plannerData.titlePrefix, plannerData.titleAccent);
      renderGoals(plannerData.goals);
      renderDeliverables(plannerData.topDeliverables);
      renderBlocks(plannerData.blocks);
      loadState();
    })();
  </script>
</html>
